<!DOCTYPE html>

<html>
	<head>
		<title>Colaborando com um Workflow Centralizado</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	</head>
	<body>
		<h1>Colaborando com um Workflow Centralizado</h1>

		<p>
		O Git é uma das ferramentas de versionamento mais flexíveis no sentido
		de permitir que um grupo de pessoas trabalhando em um projeto possam
		seguir qualquer tipo de workflow. Porém, utilizar um workflow que não
		se adeque às características da equipe pode causar mais confusão do que
		se não fosse utilizado nenhum versionamento. Existem três tipos básicos
		de workflow largamente utilizados que podem ser adaptados para a maioria
		dos projetos e se adequam ao tamanho da equipe e às restrições de acesso
		aos repositórios. Neste post vamos simular uma equipe de dois
		desenvolvedores colaborando com um workflow centralizado, nos próximos
		tutoriais veremos o workflow de integração e o ditador-tenentes.
		</p>

		<p>
		O workflow centralizado é indicado para equipes pequenas que utilizarão
		um único repositório remoto e nem todos tem acesso para modificar o
		branch master do servidor. Mesmo que todos tenham acesso ao master
		remoto, é indicado seguir esse workflow para evitar alterações
		indesejadas neste branch que provavelmente deve permanecer estável.
		Portanto, nesse workflow, as alterações de código são feitas em branches
		separadas e posteriormente incluídas no branch principal.
		</p>

		<p>
		Para demonstrar o workflow centralizado, vamos criar um repositório
		remoto chamado my-repo como exemplo. Por motivos de simplicidade, vamos
		utilizar o serviço do GitHub para criar o nosso repositório. A
		utilização do GitHub está fora do escopo do post, mas há inúmeros
		tutorais na internet sobre o assunto.
		</p>

		<p>
		Para reproduzir a nossa simulação, caso você não tenha um parceiro com
		outro computador, basta adicionar o repositório remoto em dois
		diretórios diferentes. Dentro de cada diretório, que chamaremos de
		admin-repo e coworker-repo, inicialize-o como repositório git e adicione
		o endereço do repositório remoto.
		</p>

		<p>
		$ git init
		$ git remote add origin https://github.com/username/repo-name.git
		</p>

		<p>
		Onde username é o seu username do GitHub e repo-name é o nome do
		repositório remoto. Dessa forma, quando simularmos a ação do admin do
		repositório remoto, executaremos os comandos no diretório admin-repo.
		Para simular a ação do colaborador, o faremos no diretório
		coworker-repo. Dito isso, vamos começar a simular a utilização do
		workflow centralizado.
		</p>

		<p>
		Suponha que o admin do repositório remoto criou uma classe chamada
		ShowMessage, fez commit e, como tem autorização para atualizar
		diretamente o branch master remoto, fez um push diretamente para esse
		branch no servidor.
		</p>

		<p>
		---ShowMessage.java---
		</p>

		<p>
		$ git add ShowMessage.java
		$ git commit -m "Classe ShowMessage criada"
		$ git push origin master
		</p>

		<p>
		---Imagem do repositório remoto---
		</p>

		<p>
		O colaborador então, para trazer a classe incluída pelo admin, faz um
		fetch e tem a ideia de criar um novo método que retorna a mesma mensagem
		em italiano. Como não poderá subir a alteração diretamente para o
		master, o colaborador cria um branch local chamado newLanguage e altera
		a classe nesse branch.
		</p>

		<p>
		$ git fetch origin
		$ git merge origin/master
		$ git branch newLanguage
		$ git checkout newLanguage
		</p>

		<p>
		---Imagem do repositório local do colaborador---
		</p>

		<p>
		---ShowMessage.java modificado---
		</p>
	</body>
</html>
