<!DOCTYPE html>

<html>
	<head>
		<title>Os Três Tipos de Reset</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	</head>
	<body>
		<h1>Os Três Tipos de Reset</h1>

		<p>
		O comando reset é um dos comandos mais poderosos e ao mesmo tempo um dos
		menos indicados por muitos usuários do Git. O principal motivo é o
		receio de que as alterações sejam perdidas de forma irreversível. Ocorre
		que muitos desse usuários não sabem que há mais de um tipo de reset, e
		não apenas o reset --hard, que é o que deve ser utilizado com mais
		cuidado e, porém, o mais comum. Neste tutorial, veremos que, sabendo
		diferenciar os tipos de reset e utilizar o tipo mais adequado, não há
		nada com o que se preocupar.
		</p>

		<p>
		Antes de falar sobre os tipos de reset, é importante entender as três
		áreas lógicas de um repositório Git que serão afetadas pelo comando. O
		ponteiro HEAD aponta para o último grupo de alterações(snapshot)
		comitado. Podemos alterar para qual commit o HEAD aponta executando o
		comando commit ou o reset, como veremos. A área index, também chamada
		área de stage, contém o próximo snapshot a ser commitado. Alteramos a
		área de index quando executamos o comando add. Por fim, o diretório
		de working contém as alterações que ainda não foram adicionadas à área
		de stage.
		</p>
		
		<p>
		---Imagem da área de stage, de working e o ponteiro HEAD---
		</p>
		
		<h2>
		reset --soft
		</h2>

		<p>
		O primeiro tipo de reset é utilizado com a opção --soft e move apenas o
		ponteiro HEAD para algum outro commit, sem alterar a área de stage ou o
		diretório de working. Essa é a opção mais segura entre as três, pois
		caso seja executada por engano, todo o trabalho atual ainda está
		acessível. Como exemplo, imagine que em um repositório aconteceram três
		commits e não houve nenhuma alteração de arquivos depois do último
		commit, ou seja, as áreas de stage e o diretório de working estão
		exatamente iguais ao commit mais recente.
		</p>

		<p>
		---Ponteiro HEAD, área de stage e diretório de working---
		</p>

		<p>
		Se executarmos o comando
		</p>

		<p>
		$ git reset --soft HEAD~
		</p>

		<p>
		o ponteiro HEAD será movido para o commit anterior e as áreas de stage e
		working não serão alteradas. Caso quiséssemos commitar novamente o
		trabalho atual, bastaria executar outro comando commit, já que as
		versões mais recentes dos arquivos estão na área de stage prontas para
		serem submetidas.
		</p>

		<p>
		Observe que, ao invés do parent do commit atual(HEAD~), poderíamos
		especificar qualquer commit alcançável pelo ponteiro HEAD pelo seu
		código SHA-1. Por exemplo, executar o comando
		</p>

		<p>
		$ git reset --soft ab319bc
		</p>

		<p>
		teria o mesmo efeito de executar o comando anterior.
		</p>

		<h2>
		reset --mixed
		</h2>

		<p>
		O segundo tipo de reset pode ser utilizado com a opção --mixed ou, por
		ser o tipo default, somente com o comando reset. Essa opção, além de
		mover o ponteiro HEAD, faz com que a área de stage contenha o mesmo
		snapshot do commit para o qual o ponteiro HEAD foi movido, porém não
		afeta o diretório de working. Por exemplo, imagine que em um repositório
		foram executados três commits e nenhuma alteração foi feita após o
		último commit.
		</p>

		<p>
		---ponteiro HEAD, área de stage e diretório de working---
		</p>

		<p>
		Se executarmos o comando
		</p>

		<p>
		$ git reset HEAD~
		</p>

		<p>
		o ponteiro HEAD será movido para o commit anterior ao atual, a área de
		stage terá o mesmo conteúdo do commit apontado pelo HEAD e o diretório
		de working não será modificado.
		</p>

		<p>
		---ponteiro HEAD movido, área de stage alterada e diretório de working
		intacto---
		</p>

		<p>
		Essa opção de reset é mais drástica do que a opção --soft, porém, como o
		diretório de working não é modificado, as versões mais recentes dos
		arquivos não são perdidos e podem ser adicionados à área de stage e
		commitados novamente.
		</p>
	</body>
</html>
